#!/bin/bash

# ANSI color codes
RED="\033[0;31m"
GREEN="\033[0;32m"
BLUE="\033[0;34m"
NC="\033[0m" # No color

# Function: parse_and_store_defaults
parse_and_store_defaults() {
    local app_name=$1
    local app_path="/pg/apps/${app_name}"
    local config_path="/pg/config/${app_name}.cfg"

    # Check if the config file exists, create it if not
    [[ ! -f "$config_path" ]] && touch "$config_path"

    # Read through the app script for lines starting with "#####"
    while IFS= read -r line; do
        if [[ "$line" =~ ^##### ]]; then
            # Remove leading "##### " and extract the key and value
            local trimmed_line=$(echo "$line" | sed 's/^##### //')
            local key=$(echo "$trimmed_line" | cut -d':' -f1 | tr '[:upper:]' '[:lower:]' | tr ' ' '_')
            local value=$(echo "$trimmed_line" | cut -d':' -f2 | xargs)

            # Check if the key already exists in the config file, add it if not
            if ! grep -q "^$key=" "$config_path"; then
                echo "$key=$value" >> "$config_path"
            fi
        fi
    done < "$app_path"
}

# Function: apps_interface
apps_interface() {
    local app_name=$1
    local config_path="/pg/config/${app_name}.cfg"
    local default_appdata_path="/pg/appdata/${app_name}"
    local app_path="/pg/apps/${app_name}"

    # Parse and store defaults from the app script
    parse_and_store_defaults "$app_name"

    # Function to check the Docker container status
    check_deployment_status() {
        local container_status=$(docker ps --filter "name=^/${app_name}$" --format "{{.Names}}")

        if [[ "$container_status" == "$app_name" ]]; then
            echo -e "\033[0;32m[Deployed]\033[0m $app_name"
        else
            echo -e "\033[0;31m[Not Deployed]\033[0m $app_name"
        fi
    }

    # Function to get or set the port number
    get_or_set_port_number() {
        if ! grep -q '^port_number=' "$config_path"; then
            port_number=$(awk '/# Default Port:/ {print $NF}' "$app_path")
            [[ -n "$port_number" ]] && echo "port_number=${port_number}" >> "$config_path" || {
                echo "Error: Default port not found in $app_path."
                exit 1
            }
        else
            source "$config_path"
        fi
    }

    # Function to change the port number
    change_port_number() {
        clear
        local port_code=$(printf "%04d" $((RANDOM % 10000)))
        echo "Current Port: $port_number"
        echo ""
        while true; do
            read -p "$(echo -e "Do you want to change the port number? Type [${RED}${port_code}${NC}] to proceed or [${GREEN}no${NC}] to cancel: ")" port_choice
            if [[ "$port_choice" == "$port_code" ]]; then
                break
            elif [[ "${port_choice,,}" == "no" ]]; then
                echo "Operation cancelled."
                return
            else
                echo -e "${RED}Invalid response.${NC} Please type [${RED}${port_code}${NC}] or [${GREEN}no${NC}]."
            fi
        done
        read -p "Enter the new Port for $app_name (1-65000) or type [exit] to cancel: " new_port_number

        if [[ "$new_port_number" =~ ^[0-9]+$ ]] && ((new_port_number >= 1 && new_port_number <= 65000)); then
            sed -i "s/^port_number=.*/port_number=${new_port_number}/" "$config_path"
            stop_and_remove_app
            redeploy_app
        elif [[ "$new_port_number" == "exit" ]]; then
            echo "No changes made."
        else
            echo "Invalid input. Please enter a number between 1 and 65000."
            read -p "Press Enter to continue..."
            change_port_number  # Recursive call to retry port change
        fi
    }

    # Function to validate the appdata path
    validate_or_create_path() {
        [[ -d "$1" ]] || mkdir -p "$1" || return 1
        return 0
    }

    # Function to change the appdata path
    change_appdata_path() {
        clear
        echo "Current Appdata Path: $appdata_path"
        echo ""
        local path_code=$(printf "%04d" $((RANDOM % 10000)))
        while true; do
            read -p "$(echo -e "Do you want to change the appdata path? Type [${RED}${path_code}${NC}] to proceed or [${GREEN}no${NC}] to cancel: ")" change_choice
            if [[ "$change_choice" == "$path_code" ]]; then
                break
            elif [[ "${change_choice,,}" == "no" ]]; then
                echo "Operation cancelled."
                return
            else
                echo -e "${RED}Invalid response.${NC} Please type [${RED}${path_code}${NC}] or [${GREEN}no${NC}]."
            fi
        done
        while true; do
            read -p "Enter the new Appdata Path for $app_name or type [exit] to cancel: " new_appdata_path

            if [[ "$new_appdata_path" == "exit" ]]; then
                echo "No changes made."
                return
            elif validate_or_create_path "$new_appdata_path"; then
                move_or_delete_appdata "$new_appdata_path"
                stop_and_remove_app
                redeploy_app
                break
            else
                echo "Invalid path. Please provide a valid path."
                read -p "Press Enter to continue..."
            fi
        done
    }

    # Function to move or delete appdata
    move_or_delete_appdata() {
        if [[ -z "$(ls -A "$appdata_path")" ]]; then
            echo "The current appdata directory is empty. No data will be moved."
        else
            read -p "Do you want to move the prior appdata to the new location? Type: yes / no / exit: " move_choice
            case ${move_choice,,} in  # Convert input to lowercase
                yes)
                    mv "$appdata_path/"* "$1/" && echo "Data moved to the new location: $1"
                    ;;
                no)
                    read -p "Do you want to delete the old appdata? Type: yes / no: " delete_choice
                    [[ ${delete_choice,,} == "yes" ]] && rm -rf "$appdata_path" && echo "Old appdata deleted."
                    ;;
                exit)
                    echo "Operation aborted."
                    return
                    ;;
                *)
                    echo "Invalid input. Operation aborted."
                    return
                    ;;
            esac
        fi
        appdata_path=$1
        sed -i "s|^appdata_path=.*|appdata_path=${appdata_path}|" "$config_path"
    }

    # Function to stop and remove the app's Docker container
    stop_and_remove_app() {
        docker ps --filter "name=^/${app_name}$" --format "{{.Names}}" &> /dev/null
        if [[ $? -eq 0 ]]; then
            echo "Stopping and removing the existing container for $app_name ..."
            docker stop "$app_name" && docker rm "$app_name"
        else
            echo "Container $app_name is not running."
        fi
    }

    # Function to deploy the app's Docker container
    redeploy_app() {
        echo "Deploying $app_name..."
        bash "$app_path" "$app_name"
        echo -e "${BLUE}${app_name}${NC} has been deployed."
        read -p "Press Enter to continue..."
    }

    # Function to kill the Docker container
    kill_docker_container() {
        clear
        local kill_code=$(printf "%04d" $((RANDOM % 10000)))
        while true; do
            read -p "$(echo -e "Are you sure you want to kill the Docker container?\nType [${RED}${kill_code}${NC}] to proceed or [${GREEN}no${NC}] to cancel: ")" kill_choice
            if [[ "$kill_choice" == "$kill_code" ]]; then
                docker stop "$app_name"
                docker rm "$app_name"
                echo "Docker container $app_name has been killed."
                break
            elif [[ "${kill_choice,,}" == "no" ]]; then
                echo "Operation cancelled."
                break
            else
                echo -e "${RED}Invalid response.${NC} Please type [${RED}${kill_code}${NC}] or [${GREEN}no${NC}]."
            fi
        done
    }

    # Function to reset the config file to default
    reset_config_file() {
        clear
        local reset_code=$(printf "%04d" $((RANDOM % 10000)))
        echo -e "${RED}Warning: This is an advanced option.${NC}"
        echo "Visit https://plexguide.com/wiki/link-not-set for more information."
        echo ""
        echo "This will erase the current config file and restore a default config file."
        echo "The Docker container will be stopped and removed if running."
        echo "This will not erase any data; your data will remain in its original location."
        echo ""
        while true; do
            read -p "$(echo -e "Do you want to proceed? Type [${RED}${reset_code}${NC}] to proceed or [${GREEN}no${NC}] to cancel: ")" reset_choice
            if [[ "$reset_choice" == "$reset_code" ]]; then
                rm -f "$config_path"
                echo "Config file has been reset to default."
                touch "$config_path"
                parse_and_store_defaults "$app_name"
                echo "The config file has been regenerated."
                read -p "Press Enter to continue..."
                return
            elif [[ "${reset_choice,,}" == "no" ]]; then
                echo "Operation cancelled."
                return
            else
                echo -e "${RED}Invalid response.${NC} Please type [${RED}${reset_code}${NC}] or [${GREEN}no${NC}]."
            fi
        done
    }

    # Initial setup: Create config file, store app_name, set default appdata path
    [[ ! -f "$config_path" ]] && touch "$config_path"
    grep -q '^app_name=' "$config_path" || echo "app_name=${app_name}" >> "$config_path"
    
    # Get the port number and ensure appdata directory exists
    get_or_set_port_number
    validate_or_create_path "$appdata_path"

    # Menu
    while true; do
        clear

        # Re-source the config file to refresh values
        source "$config_path"

        check_deployment_status  # Display the initial status
        echo ""
        echo "D) Deploy $app_name"
        echo "A) Appdata Path: $appdata_path"
        echo "P) Port: $port_number"
        echo "E) Edit Config File"
        echo "K) Kill Docker Container"
        echo "X) Expose Port"
        echo "Y) Default the Config File"
        echo "Z) Exit"
        echo ""

        read -p "Choose an option: " choice

        case ${choice,,} in  # Convert input to lowercase
            d)
                clear
                local deploy_code=$(printf "%04d" $((RANDOM % 10000)))
                while true; do
                    read -p "$(echo -e "Deploy/Redeploy $app_name?\nType [${RED}${deploy_code}${NC}] to proceed or [${GREEN}no${NC}] to cancel: ")" deploy_choice
                    if [[ "$deploy_choice" == "$deploy_code" ]]; then
                        stop_and_remove_app
                        redeploy_app  # Deploy the container after stopping/removing
                        break
                    elif [[ "${deploy_choice,,}" == "no" ]]; then
                        echo "Operation cancelled."
                        break
                    else
                        echo -e "${RED}Invalid response.${NC} Please type [${RED}${deploy_code}${NC}] or [${GREEN}no${NC}]."
                    fi
                done
                ;;
            a)
                change_appdata_path
                ;;
            p)
                change_port_number
                ;;
            e)
                clear
                local edit_code=$(printf "%04d" $((RANDOM % 10000)))
                echo -e "${RED}Warning: This is an advanced option.${NC}"
                echo "Visit https://plexguide.com/wiki/not-generated-yet for more information."
                echo ""
                echo "If the container is running, it will be stopped/killed and removed due to the changes made."
                echo "You will need to redeploy the container manually."
                echo "Once changes are made, press CTRL+X to save and exit."
                echo ""
                while true; do
                    read -p "$(echo -e "Do you want to proceed? Type [${RED}${edit_code}${NC}] to proceed or [${GREEN}no${NC}] to cancel: ")" edit_choice
                    if [[ "$edit_choice" == "$edit_code" ]]; then
                        nano "$config_path"
                        stop_and_remove_app
                        break
                    elif [[ "${edit_choice,,}" == "no" ]]; then
                        echo "Operation cancelled."
                        break
                    else
                        echo -e "${RED}Invalid response.${NC} Please type [${RED}${edit_code}${NC}] or [${GREEN}no${NC}]."
                    fi
                done
                ;;
            k)
                kill_docker_container
                ;;
            x)
                bash /pg/scripts/expose.sh "$app_name"
                ;;
            y)
                reset_config_file
                ;;
            z)
                break
                ;;
            *)
                echo "Invalid option, please try again."
                read -p "Press Enter to continue..."
                ;;
        esac
    done
}
